package com.hh.myproject.base;

/**
 * @author hejiayuan
 * @date 2020-12-09 17:53
 */
public class SychroReference {
    public static void main(String[] args) {
        /*
          java内存模型   对象的head中 的mark word 中存了锁的信息
         线程一进入同步代码块时成功获取到锁
            从无锁状态  升级为  ---偏向锁  大多数时候是不存在锁竞争的，存在一个竞争情况少的场景
                                         偏向锁的存在为了避免有同步但是没有竞争的时候过度消耗程序性能。 偏向锁不会主动释放锁。

         偏向锁 原理----当线程1进入同步代码块时，首先需要获取锁，如果当前的锁对象的状态是无锁的时候，
                        线程1可以顺利获取到锁对象，然后会将当前线程的threadID记录到 锁对象的对象头
                        mark word 中，如果下次再进入同步代码块，会将mark word中的threadID和当前线程
                        的threadID进行比较，如果一致则无需使用cas加锁解锁。
                        如果不一致，也就是其他线程 如线程2正在或者曾经持有这把锁。注意 这个正在或者曾经
                        由于偏向锁不会主动释放锁，因此每个线程进来获得锁的时候都需要判断锁对象的mar word中
                        对应的threadID是否存活，如果没有存活（曾经持有）则锁对象被重置为无锁状态，则其他线程可获取锁，
                        并将其设置为偏向锁（重复以上过程）
                        如果线程2还存活，那么此时查找该线程的栈帧信息，如果还需要持有这个锁对象的话，此时需要撤销偏向锁----升级为  轻量级锁
                        （为什么需要设置成轻量级锁呢？）偏向锁适用于一个线程多次获取一个锁，此时可能有多个线程来竞争，不适用。
           轻量级锁   为何引入----偏向锁考虑的情况是有同步，但是无竞争时程序的效率，而轻量级锁重点是竞争锁对象的线程不多，
                            并且持有锁的时间也不长的场景。因为阻塞线程需要cpu从用户态转到内核态，代价比较大，如果刚刚获取锁不久就释放，
                            付出的代价较大，此时干脆不阻塞线程，而是转为自旋等待锁释放。
                     原理及升级过程
                        线程1获取轻量级锁时会先把锁对象的对象头mark word 复制一份到线程1的栈帧中用于存储锁记录的空间（DisplacedMarkword
                        ）然后使用cas把对象头中的内容替换为线程1存储的displacedMarkword 地址
                        使用cas保证其他线程也在竞争锁时的安全性。
                        如果线程1成功了，线程2会自旋等待，如果自旋次数到达上限，此时会转换为重量级锁。自旋消耗cpu。
                        或者除了线程2在自旋，又有其他线程竞争锁，那么也会从轻量级锁升级为重量级锁。
                        重量级锁会将除了拥有锁的线程都阻塞，防止cpu空转。

        　*/
    }
}
